// Dashboard Loading Animation Controller
class DashboardLoadingController {
    constructor() {
        this.dashboardLoading = document.getElementById('dashboard-loading');
        this.isLoaded = false;
        this.init();
    }

    init() {
        // Start loading sequence when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                this.startLoadingSequence();
            });
        } else {
            this.startLoadingSequence();
        }
    }

    startLoadingSequence() {
        if (this.isLoaded) return;
        this.isLoaded = true;

        // Update loading text after 1 second
        setTimeout(() => {
            const loadingText = document.querySelector('.dashboard-loading-text');
            const loadingSubtext = document.querySelector('.dashboard-loading-subtext');
            if (loadingText) {
                loadingText.textContent = 'SUCCESS';
            }
            if (loadingSubtext) {
                loadingSubtext.textContent = 'Thank You';
            }
            
            // Trigger animation for speedometer components immediately when SUCCESS appears
            this.showComponents();
        }, 1000);

        // Hide dashboard loading indicator after animations complete
        setTimeout(() => {
            if (this.dashboardLoading) {
                this.dashboardLoading.style.display = 'none';
            }
        }, 2000);
    }

    showComponents() {
        // Show speedometer
        const speedometer = document.querySelector('.speedometer');
        if (speedometer) {
            speedometer.classList.add('show');
        }

        // Show radio container
        const radioContainer = document.querySelector('.radio-container');
        if (radioContainer) {
            radioContainer.classList.add('show');
        }

        // Show volume toggle button
        const volumeToggleBtn = document.getElementById('volume-toggle-btn');
        if (volumeToggleBtn) {
            volumeToggleBtn.classList.add('show');
        }
    }
}

// Initialize dashboard loading controller
const dashboardLoadingController = new DashboardLoadingController();

// Variabel untuk menyimpan status kendaraan
let elements = {};
// Variabel tambahan untuk kendaraan
let vehicleSpeed = 0;
let engineStatus = false;
let currentGear = 0; // Default gear (0 = neutral)

// Variabel untuk deteksi tombol S
let sKeyPressed = false;
let sKeyTimer = null;
let isReversing = false; // Status untuk mode reverse

// Event listener untuk tombol keyboard
document.addEventListener('keydown', function(event) {
    // Jika tombol S ditekan
    if (event.key === 's' || event.key === 'S') {
        if (!sKeyPressed) {
            sKeyPressed = true;
            // Mulai timer untuk 0.5 detik
            sKeyTimer = setTimeout(function() {
                isReversing = true;
                // Update tampilan gear menjadi R
                if (elements.gearValue) {
                    elements.gearValue.innerText = 'R';
                }
                console.log("Reverse mode activated");
            }, 50); // 0.005 detik
        }
    }
});

document.addEventListener('keyup', function(event) {
    // Jika tombol S dilepaskan
    if (event.key === 's' || event.key === 'S') {
        sKeyPressed = false;
        // Batalkan timer jika masih aktif
        if (sKeyTimer) {
            clearTimeout(sKeyTimer);
            sKeyTimer = null;
        }
        // Nonaktifkan mode reverse
        isReversing = false;
        // Kembalikan tampilan gear ke nilai normal
        updateGearBasedOnConditions();
        console.log("Reverse mode deactivated");
    }
});
let currentRPM = 0, rpmAnimationFrame;
let turnSignalState = 0;
let turnSignalBlinkInterval = null;
let blinkVisible = true;
let leftBlinkInterval = null, rightBlinkInterval = null;
let leftBlinkOn = false, rightBlinkOn = false;
let indicators = 0, headlightState = 0, seatbeltState = 0;
let engineAudio; // Declare engineAudio variable
let engineOn = false;
let engineHealth = 1.0; // Track engine health

// Sound elements
let engineStartSound, engineStopSound, indicatorSound, seatbeltWarningSound;
// Sound intervals
let indicatorSoundInterval = null;
let seatbeltWarningInterval = null;
// Track previous engine state
let previousEngineState = false;

function setEngine(state) {
    const engineIcon = document.getElementById('engine-icon');
    const dialSpeedo = document.querySelector('.dial-speedo'); // Get the dial-speedo element

    // Only play sounds if the state actually changed
    if (state !== previousEngineState) {
        if (state) {
            // Play engine start sound
            if (engineStartSound) {
                engineStartSound.currentTime = 0;
                engineStartSound.play().catch(e => console.log("Engine start sound play failed:", e));
            }
            
            // Tidak perlu menambahkan class active untuk efek glow
            if (engineAudio && !engineOn) {
                engineAudio.loop = false; // Ensure the sound does not loop
                engineAudio.play();
            }
            if (dialSpeedo) {
                dialSpeedo.classList.add('engine-on-background');
            }
            
            // Add glow effect when engine is on
            if (engineHealth >= 0.5) {
                engineIcon.classList.add('engine-glow-green');
                engineIcon.classList.remove('engine-glow-orange');
            } else {
                engineIcon.classList.add('engine-glow-orange');
                engineIcon.classList.remove('engine-glow-green');
            }
        } else {
            // Play engine stop sound
            if (engineStopSound) {
                engineStopSound.currentTime = 0;
                engineStopSound.play().catch(e => console.log("Engine stop sound play failed:", e));
            }
            
            // Tidak perlu menghapus class active
            if (engineAudio) {
                engineAudio.pause();
                engineAudio.currentTime = 0; // Reset sound to beginning
            }
            if (dialSpeedo) {
                dialSpeedo.classList.remove('engine-on-background');
            }
            
            // Remove glow effects when engine is off
            engineIcon.classList.remove('engine-glow-green');
            engineIcon.classList.remove('engine-glow-orange');
        }
        previousEngineState = state;
    }
    engineOn = state;
    
    // Untuk debugging - log status engine
    console.log("Engine status:", state);
}

function setHeadlights(state) {
    const indicator = document.getElementById('headlights');
    headlightState = state;

    switch (state) {
        case 1:
            indicator.src = 'img/headlight-on.png';
            break;
        case 2:
            indicator.src = 'img/headlight-high.png';
            break;
        default:
            indicator.src = 'img/headlight-off.png';
    }
}

function setSeatbelts(state) {
    const seatbelt = document.getElementById('seatbelts');
    seatbelt.src = state ? 'img/seatbelt-on.png' : 'img/seatbelt-off.png';
    
    // Handle seatbelt warning sound
    if (!state && !seatbeltWarningInterval) {
        // Start repeating warning sound if seatbelt is not fastened
        seatbeltWarningInterval = setInterval(() => {
            if (seatbeltWarningSound) {
                seatbeltWarningSound.currentTime = 0;
                seatbeltWarningSound.play().catch(e => console.log("Seatbelt warning sound play failed:", e));
            }
        }, 2000); // Play every 2 seconds
    } else if (state) {
        // Stop warning sound if seatbelt is fastened
        if (seatbeltWarningInterval) {
            clearInterval(seatbeltWarningInterval);
            seatbeltWarningInterval = null;
        }
        if (seatbeltWarningSound) {
            seatbeltWarningSound.pause();
            seatbeltWarningSound.currentTime = 0;
        }
    }
}

function setSpeed(speedValue) {
    const speed = Math.round(speedValue * 2.236936);
    elements.speedValue.innerText = speed.toString().padStart(3, '0');
    vehicleSpeed = speed;
    
    // Update gear display berdasarkan kecepatan dan kondisi kendaraan
    // Kecuali jika dalam mode reverse (tombol S ditekan)
    if (!isReversing) {
        updateGearBasedOnConditions();
    }
}

function setGear(gearValue) {
    // Simpan nilai gear yang diterima
    currentGear = gearValue;
    
    // Jangan ubah tampilan gear jika dalam mode reverse
    if (isReversing) {
        return;
    }
    
    // Saat fungsi setGear dipanggil, kita langsung memperbarui tampilan
    // tetapi updateGearBasedOnConditions akan menimpa nilai ini jika perlu
    if (gearValue === 'R' || gearValue === 'r' || gearValue === -1) {
        elements.gearValue.innerText = 'R';
    } else if (gearValue === 'N' || gearValue === 'n' || gearValue === 0) {
        elements.gearValue.innerText = 'N';
    } else if (gearValue === 'P' || gearValue === 'p') {
        elements.gearValue.innerText = 'P';
    } else {
        elements.gearValue.innerText = String(gearValue);
    }
}

// Fungsi yang diperbarui untuk mengatur status mesin
function setEngine(state) {
    const engineIcon = document.getElementById('engine-icon');
    const dialSpeedo = document.querySelector('.dial-speedo'); // Get the dial-speedo element

    // Only play sounds if the state actually changed
    if (state !== previousEngineState) {
        if (state) {
            // Play engine start sound
            if (engineStartSound) {
                engineStartSound.currentTime = 0;
                engineStartSound.play().catch(e => console.log("Engine start sound play failed:", e));
            }
            
            // Tidak perlu menambahkan class active untuk efek glow
            if (engineAudio && !engineOn) {
                engineAudio.loop = false; // Ensure the sound does not loop
                engineAudio.play();
            }
            if (dialSpeedo) {
                dialSpeedo.classList.add('engine-on-background');
            }
            
            // Add glow effect when engine is on
            if (engineHealth >= 0.5) {
                engineIcon.classList.add('engine-glow-green');
                engineIcon.classList.remove('engine-glow-orange');
            } else {
                engineIcon.classList.add('engine-glow-orange');
                engineIcon.classList.remove('engine-glow-green');
            }
        } else {
            // Play engine stop sound
            if (engineStopSound) {
                engineStopSound.currentTime = 0;
                engineStopSound.play().catch(e => console.log("Engine stop sound play failed:", e));
            }
            
            // Tidak perlu menghapus class active
            if (engineAudio) {
                engineAudio.pause();
                engineAudio.currentTime = 0; // Reset sound to beginning
            }
            if (dialSpeedo) {
                dialSpeedo.classList.remove('engine-on-background');
            }
            
            // Remove glow effects when engine is off
            engineIcon.classList.remove('engine-glow-green');
            engineIcon.classList.remove('engine-glow-orange');
        }
        previousEngineState = state;
    }
    engineOn = state;
    engineStatus = state;
    
    // Update gear display berdasarkan status mesin
    // Kecuali jika dalam mode reverse (tombol S ditekan)
    if (!isReversing) {
        updateGearBasedOnConditions();
    }
    
    // Untuk debugging - log status engine
    console.log("Engine status:", state);
}

// Fungsi baru untuk memperbarui tampilan gear berdasarkan status mesin
function updateGearDisplayForEngineState() {
    // Jika dalam mode reverse, tetap tampilkan R
    if (isReversing) {
        elements.gearValue.innerText = 'R';
        console.log("Gear display updated to: R (reverse mode active)");
        return;
    }
    
    // Jika mesin mati, tampilkan P
    if (!engineStatus) {
        elements.gearValue.innerText = 'P';
        console.log("Gear display updated to: P (engine off)");
    }
    // Jika mesin hidup, kembalikan ke gear yang seharusnya
    else {
        setGear(currentGear);
    }
}

// Fungsi baru untuk memperbarui tampilan gear berdasarkan kondisi kendaraan
function updateGearBasedOnConditions() {
    // Jika dalam mode reverse (tombol S ditekan), tetap tampilkan R
    if (isReversing) {
        elements.gearValue.innerText = 'R';
        return;
    }
    
    // Jika mesin mati, tampilkan P
    if (!engineStatus) {
        elements.gearValue.innerText = 'P';
        return;
    }
    
    // Jika gear adalah -1 (reverse), tampilkan R
    if (currentGear === -1) {
        elements.gearValue.innerText = 'R';
        return;
    }
    
    // Jika kecepatan 0 dan mesin hidup, tampilkan N
    if (vehicleSpeed === 0 && engineStatus) {
        elements.gearValue.innerText = 'N';
        return;
    }
    
    // Untuk kecepatan positif, tampilkan gear yang sedang digunakan
    // Kita asumsikan bahwa gear saat ini disetel melalui fungsi setGear
    if (vehicleSpeed > 0) {
        // Di sini kita bisa menentukan gear berdasarkan kecepatan jika diperlukan
        // Untuk sekarang, kita tetap menggunakan nilai gear yang disetel terakhir
        setGear(currentGear);
    }
}

// Fungsi baru untuk memperbarui tampilan gear berdasarkan kondisi kendaraan
function updateGearBasedOnConditions() {
    // Debug log
    console.log("Updating gear display - Engine:", engineStatus, "Speed:", vehicleSpeed, "Current gear:", currentGear);
    
    // Jika mesin mati, tampilkan P
    if (!engineStatus) {
        if (elements.gearValue.innerText !== 'P') {
            elements.gearValue.innerText = 'P';
            console.log("Gear set to P (engine off)");
        }
        return;
    }
    
    // Jika gear adalah -1 (reverse), tampilkan R
    if (currentGear === -1) {
        if (elements.gearValue.innerText !== 'R') {
            elements.gearValue.innerText = 'R';
            console.log("Gear set to R (reverse gear -1)");
        }
        return;
    }
    
    // Jika kecepatan 0 dan mesin hidup, tampilkan N
    if (vehicleSpeed === 0 && engineStatus) {
        if (elements.gearValue.innerText !== 'N') {
            elements.gearValue.innerText = 'N';
            console.log("Gear set to N (neutral)");
        }
        return;
    }
    
    // Untuk kecepatan positif, tampilkan gear yang sedang digunakan
    if (vehicleSpeed > 0) {
        // Tampilkan gear yang telah disetel
        let targetGear = '';
        if (currentGear === 'R' || currentGear === 'r') {
            targetGear = 'R';
        } else if (currentGear === 'N' || currentGear === 'n' || currentGear === 0) {
            targetGear = 'N';
        } else if (currentGear === 'P' || currentGear === 'p') {
            targetGear = 'P';
        } else {
            targetGear = String(currentGear);
        }
        
        if (elements.gearValue.innerText !== targetGear) {
            elements.gearValue.innerText = targetGear;
            console.log("Gear set to", targetGear, "(from currentGear)");
        }
    }
}

function setRPM(targetRPM) {
    cancelAnimationFrame(rpmAnimationFrame);

    const centerX = 100;
    const centerY = 100;
    const radius = 87.5;
    const minAngle = 0;
    const maxAngle = 270;
    const speed = 0.15;

    function animate() {
        const diff = targetRPM - currentRPM;

        if (Math.abs(diff) < 0.001) {
            currentRPM = targetRPM;
        } else {
            currentRPM += diff * speed;
        }

        const angle = minAngle + currentRPM * (maxAngle - minAngle);
        const arcPath = describeArc(centerX, centerY, radius, minAngle, angle);
        elements.rpmPath.setAttribute("d", arcPath);

        const tipLength = 2.5;
        const tipStart = angle - tipLength;
        const tipEnd = angle;
        const tipPath = describeArc(centerX, centerY, radius, tipStart, tipEnd);
        elements.rpmTip.setAttribute("d", tipPath);

        if (Math.abs(diff) >= 0.001) {
            rpmAnimationFrame = requestAnimationFrame(animate);
        }
    }

    animate();
}

function setLeftIndicator(state) {
    indicators = (indicators & 0b10) | (state ? 0b01 : 0b00);

    if (state) {
        startLeftBlinking();
    } else {
        stopLeftBlinking();
    }
    
    // Handle indicator sound
    handleIndicatorSound(state || (indicators & 0b10));
}

function setRightIndicator(state) {
    indicators = (indicators & 0b01) | (state ? 0b10 : 0b00);

    if (state) {
        startRightBlinking();
    } else {
        stopRightBlinking();
    }
    
    // Handle indicator sound
    handleIndicatorSound(state || (indicators & 0b01));
}

// Manages the indicator sound based on indicator state
function handleIndicatorSound(active) {
    if (active && !indicatorSoundInterval) {
        // Start the repeating sound if indicators are active
        indicatorSoundInterval = setInterval(() => {
            if ((indicators & 0b01) || (indicators & 0b10)) {
                if (indicatorSound) {
                    indicatorSound.currentTime = 0;
                    indicatorSound.play().catch(e => console.log("Indicator sound play failed:", e));
                }
            } else {
                // Stop if neither indicator is active
                if (indicatorSoundInterval) {
                    clearInterval(indicatorSoundInterval);
                    indicatorSoundInterval = null;
                }
                if (indicatorSound) {
                    indicatorSound.pause();
                    indicatorSound.currentTime = 0;
                }
            }
        }, 600); // Sync with blink animation
    } else if (!active) {
        // Stop the repeating sound
        if (indicatorSoundInterval) {
            clearInterval(indicatorSoundInterval);
            indicatorSoundInterval = null;
        }
        if (indicatorSound) {
            indicatorSound.pause();
            indicatorSound.currentTime = 0;
        }
    }
}

function startLeftBlinking() {
    if (leftBlinkInterval) return; // already blinking

    leftBlinkInterval = setInterval(() => {
        leftBlinkOn = !leftBlinkOn;
        document.getElementById("leftIndicator").src = leftBlinkOn ? "img/leftsignal-on.png" : "img/leftsignal-off.png";
    }, 400);
}

function stopLeftBlinking() {
    clearInterval(leftBlinkInterval);
    leftBlinkInterval = null;
    leftBlinkOn = false;
    document.getElementById("leftIndicator").src = "img/leftsignal-off.png";
    
    // Stop indicator sound if both indicators are off
    if (!(indicators & 0b10)) {
        handleIndicatorSound(false);
    }
}

function startRightBlinking() {
    if (rightBlinkInterval) return;

    rightBlinkInterval = setInterval(() => {
        rightBlinkOn = !rightBlinkOn;
        document.getElementById("rightIndicator").src = rightBlinkOn ? "img/rightsignal-on.png" : "img/rightsignal-off.png";
    }, 400);
}

function stopRightBlinking() {
    clearInterval(rightBlinkInterval);
    rightBlinkInterval = null;
    rightBlinkOn = false;
    document.getElementById("rightIndicator").src = "img/rightsignal-off.png";
    
    // Stop indicator sound if both indicators are off
    if (!(indicators & 0b01)) {
        handleIndicatorSound(false);
    }
}


function setEngineHealth(percent) {
    const centerX = 100;
    const centerY = 100;
    const radius = 90;

    const startAngle = 200;
    const sweepAngle = 80;
    const endAngle = startAngle + (sweepAngle * percent);

    const arc = describeArc(centerX, centerY, radius, startAngle, endAngle);
    const engineArc = document.getElementById("engine");
    engineArc.setAttribute("d", arc);
    
    // Ubah warna menjadi merah jika persentase di bawah 30%
    if (percent < 0.3) {
        engineArc.classList.remove("engine");
        engineArc.setAttribute("stroke", "#ff0000"); // Merah
    } else {
        engineArc.classList.add("engine");
        engineArc.removeAttribute("stroke");
    }
}

function setfuelHealth(percent) {
    const centerX = 100;
    const centerY = 100;
    const radius = 90;

    const startAngle = 150;
    const sweepAngle = 80;
    const endAngle = startAngle + (sweepAngle * percent);

    const arc = describeArc(centerX, centerY, radius, startAngle, endAngle);
    const fuelArc = document.getElementById("fuel");
    fuelArc.setAttribute("d", arc);
    
    // Ubah warna menjadi merah jika persentase di bawah 30%
    if (percent < 0.3) {
        fuelArc.classList.remove("fuel");
        fuelArc.setAttribute("stroke", "#ff0000"); // Merah
    } else {
        fuelArc.classList.add("fuel");
        fuelArc.removeAttribute("stroke");
    }
}

function polarToCartesian(cx, cy, r, angleDeg) {
    const angleRad = (angleDeg - 90) * Math.PI / 180.0;
    return {
        x: cx + r * Math.cos(angleRad),
        y: cy + r * Math.sin(angleRad)
    };
}

function describeArc(x, y, radius, startAngle, endAngle) {
    const start = polarToCartesian(x, y, radius, endAngle);
    const end = polarToCartesian(x, y, radius, startAngle);

    const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

    return [
        "M", start.x, start.y,
        "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y
    ].join(" ");
}

function createTicks() {
    const ticksContainer = document.querySelector('.ticks');
    const tickCount = 10;

    for (let i = 0; i < tickCount; i++) {
        const tick = document.createElement('div');
        tick.className = 'tick';
        const angle = (i / (tickCount - 1)) * 270 - 135;
        tick.style.transform = `rotate(${angle}deg) translateY(-115px)`;
        ticksContainer.appendChild(tick);
    }
}

function createCircularNumbers() {
    const container = document.querySelector('.circular-number');
    const count = 10;
    const radius = 130;
    const centerX = 150;
    const centerY = 150;

    for (let i = 0; i < count; i++) {
        const angle = (i / (count - 1)) * 270 + 90;
        const rad = angle * (Math.PI / 180);
        const x = centerX + radius * Math.cos(rad);
        const y = centerY + radius * Math.sin(rad);

        const num = document.createElement('span');
        num.className = 'number';
        num.textContent = i;
        num.style.left = `${x}px`;
        num.style.top = `${y}px`;

        container.appendChild(num);
    }
}

createTicks();
createCircularNumbers();

function setFuel(fuel) {
    elements.fuelHealth.innerText = `${(fuel * 100).toFixed(1)}%`; // optional
    setfuelHealth(fuel); // <- update the arc visually
}

function setHealth(health) {
    elements.engineHealth.innerText = `${(health * 100).toFixed(1)}%`; // optional
    setEngineHealth(health); // <- update the arc visually
    
    // Update engine health variable
    engineHealth = health;
    
    // Update engine icon glow based on health
    const engineIcon = document.getElementById('engine-icon');
    if (engineOn) {
        if (health >= 0.5) {
            engineIcon.classList.add('engine-glow-green');
            engineIcon.classList.remove('engine-glow-orange');
        } else {
            engineIcon.classList.add('engine-glow-orange');
            engineIcon.classList.remove('engine-glow-green');
        }
    }
}

// Global Volume Control
class GlobalVolumeControl {
    constructor() {
        this.volumeSlider = document.getElementById('global-volume-slider');
        this.volumeFill = document.getElementById('volume-fill');
        this.volumeValue = document.getElementById('global-volume-value');
        this.audioElements = [
            'engineStartSound',
            'engineStopSound',
            'indicatorSound',
            'seatbeltWarningSound',
            'engineSound',
            'radioAudio'
        ];
        
        this.init();
    }
    
    init() {
        // Set initial volume
        this.setVolume(this.volumeSlider.value);
        
        // Event listener for volume slider
        this.volumeSlider.addEventListener('input', (e) => {
            this.setVolume(e.target.value);
        });
        
        // Load saved volume from localStorage if available
        this.loadVolume();
    }
    
    setVolume(value) {
        const volume = value / 100;
        this.volumeValue.textContent = `${value}%`;
        
        // Update visual style of slider
        this.volumeFill.style.width = `${value}%`;
        
        // Add glow effect for higher volumes
        if (value > 70) {
            this.volumeFill.style.boxShadow = '0 0 15px rgba(255, 255, 255, 0.7)';
        } else if (value > 40) {
            this.volumeFill.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.5)';
        } else {
            this.volumeFill.style.boxShadow = '0 0 8px rgba(255, 255, 255, 0.4)';
        }
        
        // Update volume for all audio elements
        this.audioElements.forEach(audioId => {
            const audioElement = document.getElementById(audioId);
            if (audioElement) {
                audioElement.volume = volume;
            }
        });
        
        // Store volume in localStorage for persistence
        localStorage.setItem('globalVolume', volume);
    }
    
    loadVolume() {
        const savedVolume = localStorage.getItem('globalVolume');
        if (savedVolume !== null) {
            const volume = parseFloat(savedVolume);
            this.volumeSlider.value = volume * 100;
            this.setVolume(volume * 100);
        }
    }
}

// Custom Internet Radio Functionality
class InternetRadio {
    constructor() {
        console.log('Initializing InternetRadio');
        this.audioElement = document.getElementById('radioAudio');
        this.stationName = document.getElementById('station-name');
        this.radioStatus = document.getElementById('radio-status');
        this.prevButton = document.getElementById('prev-station');
        this.nextButton = document.getElementById('next-station');
        this.playPauseButton = document.getElementById('play-pause');
        
        // Check if all elements are found
        if (!this.audioElement) {
            console.error('radioAudio element not found');
            return;
        }
        if (!this.stationName) {
            console.error('station-name element not found');
            return;
        }
        if (!this.radioStatus) {
            console.error('radio-status element not found');
            return;
        }
        if (!this.prevButton) {
            console.error('prev-station element not found');
            return;
        }
        if (!this.nextButton) {
            console.error('next-station element not found');
            return;
        }
        if (!this.playPauseButton) {
            console.error('play-pause element not found');
            return;
        }
        
        console.log('All radio elements found');
        
        // Define stations array
        this.stations = [
            { url: "https://n07.radiojar.com/rrqf78p3bnzuv?rj-tok=AAABhY8Nl3sA002K4e2rm7K23A&rj-ttl=5", name: "Radio Jakarta" },
            { url: "https://stream.radiojar.com/rrqf78p3bnzuv", name: "Radio Trax" },
            { url: "https://streaming.radiomuslim.com/radiomuslim.mp3", name: "Radio Muslim" },
            { url: "https://live.radioistara.com/listen/radioistara/radioistara", name: "Radio Istara" },
            { url: "https://live.brayaradio.com/listen/brayaradio/stream", name: "Braya Radio" },
            { url: "https://sundaradio.com/live/sundaradio", name: "Sunda Radio" },
            { url: "https://live.harleyradioshow.com/listen/harleyradio/harleyradio", name: "Harley Radio" },
            { url: "https://s2.cloudmu.id/listen/prambors/stream", name: "Prambors Radio" },
            { url: "https://stream-156.zeno.fm/z1bs88ttrfhvv", name: "Radio Trenggalek" },
            { url: "https://static-s8.xajist.com:8787/live", name: "Radio Wijang Songko" },
            { url: "https://live.suarasalira.com/listen/suarasalira/stream", name: "Radio Suara Salira" }
        ];
        
        this.currentStationIndex = -1; // -1 means no station selected
        this.isPlaying = false;
        
        this.init();
    }

    init() {
        console.log('Initializing radio controls');
        
        // Event listeners for new buttons
        this.prevButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Previous station button clicked');
            this.previousStation();
        });
        
        this.nextButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Next station button clicked');
            this.nextStation();
        });
        
        this.playPauseButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Play/Pause button clicked');
            this.togglePlayPause();
        });
        
        // Log all event listeners to ensure they're attached
        console.log('Event listeners attached');
        console.log('prevButton listeners:', this.prevButton);
        console.log('nextButton listeners:', this.nextButton);
        console.log('playPauseButton listeners:', this.playPauseButton);
        
        // Handle audio events
        this.audioElement.addEventListener('playing', () => {
            console.log('Radio playing');
            this.radioStatus.textContent = 'PLAYING';
            this.isPlaying = true;
            this.updatePlayPauseButton();
        });
        
        this.audioElement.addEventListener('pause', () => {
            console.log('Radio paused');
            this.radioStatus.textContent = 'PAUSED';
            this.isPlaying = false;
            this.updatePlayPauseButton();
        });
        
        this.audioElement.addEventListener('ended', () => {
            console.log('Radio ended');
            this.radioStatus.textContent = 'STOPPED';
            this.isPlaying = false;
            this.updatePlayPauseButton();
        });
        
        this.audioElement.addEventListener('error', (e) => {
            console.error('Radio error:', e);
            this.radioStatus.textContent = 'ERROR';
            this.stationName.textContent = 'STATION ERROR';
            this.isPlaying = false;
            this.updatePlayPauseButton();
        });
        
        this.audioElement.addEventListener('loadstart', () => {
            console.log('Radio loading');
            this.radioStatus.textContent = 'LOADING...';
        });
        
        this.audioElement.addEventListener('canplay', () => {
            console.log('Radio can play');
            this.radioStatus.textContent = 'READY';
        });
        
        // Set initial status
        this.radioStatus.textContent = 'READY';
        this.stationName.textContent = 'Select Station';
        this.updatePlayPauseButton();
    }

    updatePlayPauseButton() {
        if (this.isPlaying) {
            this.playPauseButton.textContent = '❚❚'; // Pause symbol
        } else {
            this.playPauseButton.textContent = '▶'; // Play symbol
        }
    }

    playStation(index) {
        console.log('Playing station index:', index);
        if (index < 0 || index >= this.stations.length) {
            this.stop();
            this.stationName.textContent = 'Select Station';
            this.currentStationIndex = -1;
            return;
        }
        
        this.currentStationIndex = index;
        const station = this.stations[index];
        this.stationName.textContent = station.name;
        
        // Set the new source
        this.audioElement.src = station.url;
        
        // Play the audio
        this.audioElement.play()
            .then(() => {
                console.log('Radio playing successfully');
            })
            .catch((error) => {
                console.error('Error playing radio:', error);
                this.radioStatus.textContent = 'PLAY ERROR';
                this.stationName.textContent = 'PLAY ERROR';
            });
    }

    nextStation() {
        console.log('Next station');
        if (this.stations.length === 0) return;
        
        let nextIndex = this.currentStationIndex + 1;
        if (nextIndex >= this.stations.length) {
            nextIndex = 0; // Loop back to first station
        }
        
        this.playStation(nextIndex);
    }

    previousStation() {
        console.log('Previous station');
        if (this.stations.length === 0) return;
        
        let prevIndex = this.currentStationIndex - 1;
        if (prevIndex < 0) {
            prevIndex = this.stations.length - 1; // Loop to last station
        }
        
        this.playStation(prevIndex);
    }

    togglePlayPause() {
        console.log('Toggle play/pause, currentStationIndex:', this.currentStationIndex, 'isPlaying:', this.isPlaying);
        if (this.currentStationIndex === -1) {
            // If no station selected, start with the first one
            console.log('No station selected, playing first station');
            this.playStation(0);
        } else {
            if (this.isPlaying) {
                console.log('Pausing radio');
                this.audioElement.pause();
            } else {
                // If we have a station but it's paused, resume playing
                console.log('Playing radio');
                this.audioElement.play()
                    .then(() => {
                        console.log('Radio playing successfully');
                    })
                    .catch((error) => {
                        console.error('Error playing radio:', error);
                        this.radioStatus.textContent = 'PLAY ERROR';
                        this.stationName.textContent = 'PLAY ERROR';
                    });
            }
        }
    }

    stop() {
        console.log('Stopping radio');
        this.audioElement.pause();
        this.audioElement.src = '';
        this.radioStatus.textContent = 'STOPPED';
        this.isPlaying = false;
        this.updatePlayPauseButton();
    }
    
    // Reset radio to initial state
    reset() {
        console.log('Resetting radio');
        this.audioElement.pause();
        this.audioElement.src = '';
        this.radioStatus.textContent = 'READY';
        this.stationName.textContent = 'SELECT STATION';
        this.currentStationIndex = -1;
        this.isPlaying = false;
        this.updatePlayPauseButton();
    }
}

document.addEventListener("DOMContentLoaded", () => {
    elements = {
        speedValue: document.getElementById('speedValue'),
        gearValue: document.getElementById('gearValue'),
        seatbelt: document.getElementById('seatbelts'),
        rpmPath: document.getElementById('rpmPath'),
        rpmTip: document.getElementById('rpmTip'),
        rpmRedline: document.getElementById('rpmRedline'),
        headlights: document.getElementById('headlights'),
        fuelHealth: document.getElementById('fuel'),
        engineHealth: document.getElementById('engine'),
        leftIndicator: document.getElementById('leftIndicator'),
        rightIndicator: document.getElementById('rightIndicator'),
        dialSpeedo: document.querySelector('.dial-speedo') // Add dialSpeedo to elements
    };
    
    // Initialize sound elements
    engineStartSound = document.getElementById('engineStartSound');
    engineStopSound = document.getElementById('engineStopSound');
    indicatorSound = document.getElementById('indicatorSound');
    seatbeltWarningSound = document.getElementById('seatbeltWarningSound');
    engineAudio = document.getElementById('engineSound'); // Initialize engineAudio
    const redlineStart = 7.5 / 9;  // tick 8 out of 9 (normalized)
    const redlineEnd = 9 / 9;    // tick 9
    const fuelBgStart = 150;
    const fuelBgSweep = 80;
    const engineBgStart = 200;
    const engineBgSweep = 80;

    const centerX = 100;
    const centerY = 100;
    const radius = 87.5;
    const minAngle = 0;
    const maxAngle = 270;

    const redlineAngleStart = minAngle + redlineStart * (maxAngle - minAngle);
    const redlineAngleEnd = minAngle + redlineEnd * (maxAngle - minAngle);
    const fuelBgPath = describeArc(100, 100, 90, fuelBgStart, fuelBgStart + fuelBgSweep);
    const engineBgPath = describeArc(100, 100, 90, engineBgStart, engineBgStart + engineBgSweep);

    const redlinePath = describeArc(centerX, centerY, radius, redlineAngleStart, redlineAngleEnd);
    document.getElementById('rpmRedline').setAttribute('d', redlinePath);
    document.getElementById("fuelHealthBg").setAttribute("d", fuelBgPath);
    document.getElementById("engineHealthBg").setAttribute("d", engineBgPath);
    
    // Initialize volume toggle button
    const volumeToggleBtn = document.getElementById('volume-toggle-btn');
    const volumeContainer = document.getElementById('volume-container');
    
    // Initially hide volume container
    volumeContainer.classList.remove('active');
    
    // Toggle volume container visibility
    volumeToggleBtn.addEventListener('click', () => {
        volumeContainer.classList.toggle('active');
    });
});

// Initialize global volume control and radio when DOM is loaded
function initControls() {
    console.log('Initializing controls');
    // Initialize global volume control
    const volumeControl = new GlobalVolumeControl();
    
    // Initialize radio
    const radio = new InternetRadio();
}

// Initialize controls when DOM is loaded
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initControls);
} else {
    // DOM is already loaded
    initControls();
}

// Function to start engine icon animation after all speedometer animations are loaded
function startEngineIconAnimation() {
    // Get all the animate elements in the engine icon
    const engineAnimate1 = document.getElementById('engineAnimate1');
    const engineAnimate2 = document.getElementById('engineAnimate2');
    const engineSet1 = document.getElementById('engineSet1');
    const engineSet2 = document.getElementById('engineSet2');
    const engineAnimate3 = document.getElementById('engineAnimate3');
    const engineSet3 = document.getElementById('engineSet3');
    const engineAnimate4 = document.getElementById('engineAnimate4');
    const engineSet4 = document.getElementById('engineSet4');
    
    // Check if all elements exist
    if (engineAnimate1 && engineAnimate2 && engineSet1 && engineSet2 && 
        engineAnimate3 && engineSet3 && engineAnimate4 && engineSet4) {
        
        // Start the animations in sequence
        engineAnimate1.beginElement();
        setTimeout(() => {
            engineAnimate2.beginElement();
            engineSet2.beginElement();
        }, 600);
        setTimeout(() => {
            engineSet1.beginElement();
            engineAnimate3.beginElement();
            engineSet3.beginElement();
        }, 800);
        setTimeout(() => {
            engineAnimate4.beginElement();
            engineSet4.beginElement();
        }, 1000);
    }
}

// Start engine icon animation after dashboard loading is complete
document.addEventListener('DOMContentLoaded', function() {
    // Wait for the dashboard loading to complete (2 seconds based on the timeout in DashboardLoadingController)
    setTimeout(startEngineIconAnimation, 2000);
});

